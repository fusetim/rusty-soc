//! Master Boot Record (MBR) partitioning scheme
//!
//! This module provides types and functions for working with the Master Boot Record (MBR)
//! partitioning scheme, commonly used on storage devices like SD cards.
//!
//! Given a [BlockDevice](embedded_sdmmc::BlockDevice), you can read the MBR from the first sector
//! of the device, parse the partition table, and access individual partitions.
//!
//! This module is widely inspired by the [VolumeManager](embedded_sdmmc::VolumeManager) from the embedded-sdmmc crate,
//! but is simplified to only handle MBR partitioning. The goal of this library being to provide a minimal FAT (lightweight!!) filesystem
//! implementation for embedded systems.

use core::mem;
use embedded_sdmmc::{BlockDevice, Volume};
use crate::block::{self, Block, BlockIdx, BlockCount};

/// In the MBR block, the following should be present, otherwise it is not 
/// an MBR partition table.
pub(crate) const MBR_SIGNATURE : [u8; 2] = [0x55, 0xAA];

#[derive(Copy, Clone, PartialEq, Eq)]
pub struct VolumeInfo {
    pub index: VolumeIdx,
    pub block_start: BlockIdx,
    pub block_len: BlockCount,
}

/// Volume Manager, only support MBR partition tables.
///
/// This struct allows you to manage volumes (partitions) on a block device
/// that uses the Master Boot Record (MBR) partitioning scheme.
///
/// In particular, it allows you to open volumes by their index and access
/// their partition information.
pub struct VolumeManager<D: embedded_sdmmc::BlockDevice> {
    block_device: D,
}

/// Volume index type for identifying volumes (partitions).
///
/// It is specific to MBR partitioning, where volumes are identified by
/// their index in the partition table (0-3 for primary partitions).
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct VolumeIdx(pub u8);

impl<D: embedded_sdmmc::BlockDevice> VolumeManager<D> {
    /// Create a new VolumeManager for the given block device.
    ///
    /// # Arguments
    ///
    /// * `block_device` - The block device to manage volumes on.
    pub fn new(block_device: D) -> Self {
        Self { block_device }
    }

    /// Get a volume info by its index.
    ///
    /// # Arguments
    ///
    /// * `volume_idx` - The index of the volume to open.
    ///
    /// # Returns
    ///
    /// * `Result<VolumeInfo, embedded_sdmmc::Error>` - The opened volume or an error.
    pub fn get_volume(&mut self, volume_idx: VolumeIdx) -> Result<VolumeInfo, <D as BlockDevice>::Error> {
        // Read the MBR from the first sector
        let mut blocks = [Block::new()];
        self.block_device.read(&mut blocks, BlockIdx(0))?;
        let mbr : &MbrTable = (&*blocks[0]).into();

        // Check if the correct MBR signature is present
        if mbr.signature != MBR_SIGNATURE {
            todo!("Error: invalid MBR partition table");
        }

        // Get the partition entry
        let partition_entry = match volume_idx {
            VolumeIdx(0) => &mbr.partition_entries[0],
            VolumeIdx(1) => &mbr.partition_entries[1],
            VolumeIdx(2) => &mbr.partition_entries[2],
            VolumeIdx(3) => &mbr.partition_entries[3],
            _ => todo!("Error: invalid primary partition"),
        };

        // Check if the given entry is valid
        if !partition_entry.is_valid() {
            todo!("Error: selected partition is invalid")
        }

        // Get the start address
        let lba_start = BlockIdx(partition_entry.get_lba_start()); 
        let total_sectors = BlockCount(partition_entry.get_total_sectors()); 

        Ok(VolumeInfo {
            index: volume_idx,
            block_start: lba_start,
            block_len: total_sectors,
        })
    }
}

/// Master Boot Record (MBR) table structure.
///
/// This struct represents the layout of the MBR, including the boot code,
/// partition entries, and signature.
///
/// This structure is 512 bytes in size, matching the size of a standard MBR sector.
#[derive(Clone, PartialEq, Eq)]
#[repr(C)]
pub struct MbrTable {
    /// Boot code area
    /// Base address: 0 (0x0000)
    /// Length: 446 bytes (0x01BE)
    pub boot_code: [u8; 446],
    /// Partition entries
    /// Base address: 446 (0x01BE)
    /// Length: 64 bytes (4 entries of 16 bytes each)
    pub partition_entries: [MbrPartitionEntry; 4],
    /// Signature
    /// Base address: 510 (0x01FE)
    /// Length: 2 bytes (0x0002)
    pub signature: [u8; 2],
}

/// MBR Partition Entry structure.
///
/// This struct represents a single partition entry in the MBR partition table.
///
/// Each partition entry is 16 bytes in size and contains information about the partition,
/// including its type, starting address, and size.
#[derive(Clone, PartialEq, Eq)]
#[repr(C)]
pub struct MbrPartitionEntry {
    /// Boot indicator (0x80 = bootable, 0x00 = non-bootable)
    pub boot_indicator: u8,
    /// Starting CHS (Cylinder-Head-Sector) address
    pub starting_chs: [u8; 3],
    /// Partition type (e.g., 0x0B = FAT32, 0x83 = Linux)
    pub partition_type: u8,
    /// Ending CHS (Cylinder-Head-Sector) address
    pub ending_chs: [u8; 3],
    /// Starting Logical Block Address (LBA) of the partition
    pub starting_lba: [u8; 4],
    /// Total number of sectors in the partition
    pub total_sectors: [u8; 4],
}

impl MbrPartitionEntry {
    /// Check if the entry is valid (bootable or non-bootable).
    pub fn is_valid(&self) -> bool {
        // Bootable = 0x80
        // Non-bootable = 0x00
        // Invalid = others
        self.boot_indicator & 0x7F == 0
    }

    /// Get LBA start address
    pub fn get_lba_start(&self) -> u32 {
        u32::from_le_bytes(self.starting_lba)
    }

    /// Get the total number of sector
    pub fn get_total_sectors(&self) -> u32 {
        u32::from_le_bytes(self.total_sectors)
    }


}

impl<'a> From<&'a [u8; 16]> for &'a MbrPartitionEntry {
    fn from(bytes: &'a [u8; 16]) -> Self {
        // Safety: transmute is okay as the struct has a known layout (repr[C])
        unsafe { mem::transmute(bytes) }
    }
}

impl From<[u8; 16]> for MbrPartitionEntry {
    fn from(bytes: [u8; 16]) -> Self {
        // Safety: transmute is okay as the struct has a known layout (repr[C])
        unsafe { mem::transmute(bytes) }
    }
}

impl<'a> From<&'a [u8; 512]> for &'a MbrTable {
    fn from(bytes: &'a [u8; 512]) -> Self {
        // Safety: transmute is okay as the struct has a known layout (repr[C])
        unsafe { mem::transmute(bytes) }
    }
}

impl From<[u8; 512]> for MbrTable {
    fn from(bytes: [u8; 512]) -> Self {
        // Safety: transmute is okay as the struct has a known layout (repr[C])
        unsafe { mem::transmute(bytes) }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    const MBR_PARTITION_FAT32_BOOTABLE: [u8; 16] = [
        0x80, 0x01, 0x01, 0x00, 0x0B, 0xFE, 0xFF, 0xFF, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00,
        0x00,
    ];

    const MBR_TABLE: [u8; 512] = [
        0xfa, 0xb8, 0x00, 0x10, 0x8e, 0xd0, 0xbc, 0x00, 0xb0, 0xb8, 0x00, 0x00, 0x8e, 0xd8, 0x8e,
        0xc0, // 0x000
        0xfb, 0xbe, 0x00, 0x7c, 0xbf, 0x00, 0x06, 0xb9, 0x00, 0x02, 0xf3, 0xa4, 0xea, 0x21, 0x06,
        0x00, // 0x010
        0x00, 0xbe, 0xbe, 0x07, 0x38, 0x04, 0x75, 0x0b, 0x83, 0xc6, 0x10, 0x81, 0xfe, 0xfe, 0x07,
        0x75, // 0x020
        0xf3, 0xeb, 0x16, 0xb4, 0x02, 0xb0, 0x01, 0xbb, 0x00, 0x7c, 0xb2, 0x80, 0x8a, 0x74, 0x01,
        0x8b, // 0x030
        0x4c, 0x02, 0xcd, 0x13, 0xea, 0x00, 0x7c, 0x00, 0x00, 0xeb, 0xfe, 0x00, 0x00, 0x00, 0x00,
        0x00, // 0x040
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, // 0x050
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, // 0x060
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, // 0x070
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, // 0x080
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, // 0x090
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, // 0x0A0
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, // 0x0B0
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, // 0x0C0
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, // 0x0D0
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, // 0x0E0
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, // 0x0F0
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, // 0x100
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, // 0x110
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, // 0x120
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, // 0x130
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, // 0x140
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, // 0x150
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, // 0x160
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, // 0x170
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, // 0x180
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, // 0x190
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, // 0x1A0
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4c, 0xca, 0xde, 0x06, 0x00, 0x00, 0x00,
        0x04, // 0x1B0
        0x01, 0x04, 0x0c, 0xfe, 0xc2, 0xff, 0x01, 0x00, 0x00, 0x00, 0x33, 0x22, 0x11, 0x00, 0x00,
        0x00, // 0x1C0
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, // 0x1D0
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, // 0x1E0
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55,
        0xaa, // 0x1F0
    ];

    #[test]
    pub fn mbr_partition_entry_from_raw_bytes() {
        let raw_bytes: [u8; 16] = MBR_PARTITION_FAT32_BOOTABLE;
        let partition_entry: MbrPartitionEntry = raw_bytes.into();

        assert_eq!(partition_entry.boot_indicator, 0x80);
        assert_eq!(partition_entry.partition_type, 0x0B);
        assert_eq!(partition_entry.starting_lba, [0x3F, 0x00, 0x00, 0x00]);
        assert_eq!(partition_entry.total_sectors, [0x00, 0x08, 0x00, 0x00]);
    }

}
