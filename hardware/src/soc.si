// Pre-compilation script, embeds compiled code within a string
// Code has to be compiled into firmware/code.hex before
$$dofile('pre_include_compiled.lua')

// -- Includes -- //

// Includes the processor
$include('../lib/silice/projects/ice-v/CPUs/ice-v.si')

// Includes the GPIO peripheral
$include('./gpio.si')
// Includes the SPI peripheral
// -- DEBUG -- $ include('./spi.si')
append('../lib/fusetim/spi/SpiMaster.v')
import('../lib/fusetim/spi/SpiMasterPeripheral.v')
import('./spi_pll.v')
// Includes the DAC peripheral
$include('./dac.si')
// Includes the Audio Streamer peripheral
$include('./audio.si')
// Includes the DISPLAY peripheral
$include('./display.si')
// -- End of Includes -- //

// Setup memory size
// - addrW is the address bus width
// - the topmost bit is used to indicate peripheral access
// - we thus allocate 2^(addrW-1) uint32 of RAM
// - See ../svd.xml for memory map
$$addrW      = 15
$$periph_bit = addrW-1
// Configure BRAM (needed for write mask)
$$config['bram_wmask_byte_wenable_width'] = 'data'

// Memory interface between SOC and CPU
group mem_io
{
    uint4       wenable(0), // write enable mask (xxxx, 0:nop, 1:write)
    uint32      wdata(0),   // data to write
    uint32      rdata(0),   // data read from memory
    uint$addrW$ addr(0),    // address, init is boot address
}

// --------------------------------------------------
// SOC unit (main)
// --------------------------------------------------
//   some input/outputs do not exist in simulation and
//   are therefore enclosed in pre-processor conditions
unit main (
    output uint8 leds,
$$if BUTTONS then
    input  uint7 btns,
$$end
$$if AUDIO then
    output uint4 audio_l,
    output uint4 audio_r,
$$end
    output! uint1 oled_clk,
    output! uint1 oled_mosi,
    output! uint1 oled_dc,
    output! uint1 oled_resn,
    output uint1 oled_csn(0),
$$if VERILATOR then
    // configuration for SPIscreen simulation
    output uint2  spiscreen_driver(1/*SSD1351*/),
    output uint10 spiscreen_width(128),
    output uint10 spiscreen_height(128),
$$end
$$if SDCARD then
    output!  uint1  sd_clk,
    output!  uint1  sd_csn(1),
    output!  uint1  sd_mosi,
    input   uint1  sd_miso,
$$end
)
{

// -- Fallbacks for simulation -- //
$$if SIMULATION then
    // count cycles in simulation for debugging purposes
    uint32 cycle(0);
$$end

$$if not SDCARD then
    // for simulation ('fake' inputs/outputs)
    uint1  sd_clk(0);
    uint1  sd_csn(0);
    uint1  sd_mosi(0);
    uint1  sd_miso(0);
$$end

$$if not BUTTONS then
    // for simulation ('fake' inputs/outputs)
    uint7 btns(4);
$$end

$$if not AUDIO then
    // for simulation ('fake' inputs/outputs)
    uint4 audio_l(0);
    uint4 audio_r(0);
$$end
// -- End of fallbacks -- //
    // Instantiate the Memory Interface
    mem_io memio;

    // Instantiate our CPU
    rv32i_cpu cpu( mem <:> memio );

    // Instantiate the memory (BRAM)
    bram uint32 ram<"bram_wmask_byte">[$1<<(addrW-1)$] = $meminit$;

    // -- Peripherals -- //
    // GPIO Peripheral
    uint1 gpio_en(0);
    uint1 gpio_rst(0);
    gpio_peripheral gpio(
        rst <: gpio_rst, // no reset for now
        // Memory-mapped I/O interface
        mem_en      <: gpio_en,
        // mem_addr    <: prev_mem_addr[0,8],
        // mem_wr_data <: prev_wdata,
        // mem_wr_en   <: prev_mem_rw,
        // mem_rd_data :> memio.rdata,
        // GPIO signals
        leds        :> leds,
        btns        <: btns,
        // SPI - SD Card
        sd_cs       :> sd_csn,
        //sd_mosi     :> sd_mosi, - handled by SPI0 peripheral
        //sd_clk      :> sd_clk,  - handled by SPI0 peripheral
        //sd_miso     <: sd_miso, - handled by SPI0 peripheral
        // SPI - OLED Display
        oled_cs     :> oled_csn,
        //oled_mosi   :> oled_mosi, - handled by SPI1 peripheral
        //oled_clk    :> oled_clk,  - handled by SPI1 peripheral
        oled_dc     :> oled_dc,
        oled_res    :> oled_resn,
    );

    // SPI Peripherals
    uint1 spi0_en(0);
    uint1 spi0_rst(0);
    uint1 spi0_rclk = 0;
    uint1 spi1_en(0);
    uint1 spi1_rst(0);
    uint1 spi1_rclk = 0;
    uint1 spi_pll_rst(1);
    spi_pll spi_pll(
        clk_25 <: clock,
        rst_n <: spi_pll_rst,
        // Output clocks - Select on:
        // - apparently our SD card supports SPI 40MHz ~ 500kB/s (rclk = 80MHz) without init issues)
        // - OLED display works fine at 10MHz (rclk = 20MHz)
        //clk_160 :> spi0_rclk,
        clk_80 :> spi0_rclk,
        clk_20 :> spi1_rclk,
        //clk_5 :> spi0_rclk,
    );
    SpiMasterPeripheral spi0(
        clk        <: clock,
        rclk       <: spi0_rclk,
        rst        <: spi0_rst,
        //mem_addr   (prev_mem_addr[0,8]),
        //mem_wr_data(prev_wdata),
        //mem_wr_en  (prev_mem_rw),
        //mem_rd_data(spi0.mem_rd_data),
        spi_clk    :> sd_clk,
        spi_mosi   :> sd_mosi,
        spi_miso   <: sd_miso,
    );
    SpiMasterPeripheral spi1(
        clk        <: clock,
        rclk       <: spi1_rclk,
        rst        <: spi1_rst,
        //mem_addr   (prev_mem_addr[0,8]),
        //mem_wr_data(prev_wdata),
        //mem_wr_en  (prev_mem_rw),
        //mem_rd_data(spi0.mem_rd_data),
        spi_clk    :> oled_clk,
        spi_mosi   :> oled_mosi,
        // spi_miso   <: oled_miso, - no MISO for OLED
    );
    

    // DAC Peripheral for Audio Output
    uint1 dac_en(0);
    dac_peripheral dac(
        // Memory-mapped I/O interface
        // mem_addr    <: prev_mem_addr[0,8],
        // mem_wr_data <: prev_wdata,
        // mem_wr_en   <: prev_mem_rw,
        // Audio Output signals
        // audio_left_out  :> audio_l,
        // audio_right_out :> audio_r
    );

    // Audio Streamer Peripheral
    uint1 audio_streamer_mem_en(0);
    uint1 audio_streamer_en(0);
    audio_streamer_peripheral audio_streamer(
        // Memory-mapped I/O interface
        // mem_addr    <: prev_mem_addr[0,8],
        // mem_wr_data <: prev_wdata,
        // mem_wr_en   <: prev_mem_rw,
        // mem_rd_data :> memio.rdata,
        // Audio Output signals
        audio_left_out  :> audio_l,
        audio_right_out :> audio_r,
        // Peripheral enabled signal
        enabled         :> audio_streamer_en
    );

    // Display Peripheral for OLED Screen with Hardware Framebuffer
    /*uint1 display_peripheral_en(0);
    display_peripheral display_peripheral(
        // Memory-mapped I/O interface
        // mem_addr    <: prev_mem_addr[0,8],
        // mem_wr_data <: prev_wdata,
        // mem_wr_en   <: prev_mem_rw,
        // OLED Display SPI interface
        oled_clk    :> oled_clk,
        oled_mosi   :> oled_mosi,
        oled_dc     :> oled_dc,
        oled_resn   :> oled_resn,
        oled_csn    :> oled_csn
    );*/

    // -- End of Peripherals -- //

    // -- Internal SoC states -- //
    // Variables to record previous cycle CPU access (peripherals memory mapping)
    // The CPU issues a memory request a cycle i and expects the result at i+1
    uint$addrW$ prev_mem_addr(0);
    uint4       prev_mem_rw(0);
    uint32      prev_wdata(0);
    // -- End of Internal SoC states -- //


    always { 
        // Audio Switch - select between DAC and Audio Streamer outputs
        // audio_l = audio_streamer_en ? audio_streamer.audio_left_out : dac.audio_left_out;
        // audio_r = audio_streamer_en ? audio_streamer.audio_right_out : dac.audio_right_out;

        // Peripheral enable signals
        uint1 peripheral_en = prev_mem_addr[$periph_bit$,1]; // 100000000000000
        gpio_en = peripheral_en & (prev_mem_addr[8, 6] == 6b000001); // GPIO at 0x10400 = 0b100000100000000
        dac_en  = peripheral_en & (prev_mem_addr[8, 6] == 6b000010); // DAC at 0x10800  = 0b100001000000000
        audio_streamer_mem_en = peripheral_en & (prev_mem_addr[8, 6] == 6b000011); // Audio Streamer at 0x10C00 = 0b100001100000000
        spi0_en = peripheral_en & (prev_mem_addr[8, 6] == 6b000100); // SPI0 at 0x11000 = 0b100010000000000
        spi1_en = peripheral_en & (prev_mem_addr[8, 6] == 6b000101); // SPI1 at 0x11400 = 0b100010100000000

        // GPIO Peripheral memory-mapped I/O access
        gpio.mem_addr    = prev_mem_addr[0,8];
        gpio.mem_wr_data = prev_wdata;
        gpio.mem_wr_en   = gpio_en ? prev_mem_rw : 4b0000; // only write when enabled

        // SPI0 Peripheral memory-mapped I/O access
        spi0.mem_addr    = prev_mem_addr[0,8];
        spi0.mem_wr_data = prev_wdata;
        spi0.mem_wr_en   = spi0_en ? prev_mem_rw : 4b0000; // only write when enabled
        // SPI1 Peripheral memory-mapped I/O access
        spi1.mem_addr    = prev_mem_addr[0,8];
        spi1.mem_wr_data = prev_wdata;
        spi1.mem_wr_en   = spi1_en ? prev_mem_rw : 4b0000; // only write when enabled

        // DAC Peripheral memory-mapped I/O access
        dac.mem_addr    = prev_mem_addr[0,8];
        dac.mem_wr_data = prev_wdata;
        dac.mem_wr_en   = dac_en ? prev_mem_rw : 4b0000; // only write when enabled

        // Audio Streamer Peripheral memory-mapped I/O access
        audio_streamer.mem_addr    = prev_mem_addr[0,8];
        audio_streamer.mem_wr_data = prev_wdata;
        audio_streamer.mem_wr_en   = audio_streamer_mem_en ? prev_mem_rw : 4b0000; // only write when enabled

        // Memory Interface
        memio.rdata =   (~peripheral_en ? ram.rdata : 32b0)
                        | (peripheral_en & gpio_en ? gpio.mem_rd_data : 32b0)
                        | (peripheral_en & spi0_en ? spi0.mem_rd_data : 32b0)
                        | (peripheral_en & spi1_en ? spi1.mem_rd_data : 32b0)
                        | (peripheral_en & audio_streamer_mem_en ? audio_streamer.mem_rd_data : 32b0);
        ram.wenable = memio.wenable & {4{~memio.addr[$periph_bit$,1]}};
        //                               ^^^^^^^ no write if on peripheral addresses
        ram.wdata        = memio.wdata;
        ram.addr         = memio.addr;

        // SIMULATION ONLY: debug output for LEDs
        $$if SIMULATION then
            if (peripheral_en) {
                if (gpio_en) {
                    __display("[cycle %d] GPIO access: %h(%b) < %h > <%h>",cycle,{prev_mem_addr, 2b00},prev_mem_rw,prev_wdata,memio.rdata);
                }
                if (dac_en) {
                    __display("[cycle %d] DAC access: %h(%b) < %h",cycle,{prev_mem_addr, 2b00},prev_mem_rw,prev_wdata);
                }
                /*if (display_peripheral_en) {
                    __display("[cycle %d] DISPLAY access: %h(%b) < %h",cycle,{prev_mem_addr, 2b00},prev_mem_rw,prev_wdata);
                }*/
                if (spi0_en) {
                    __display("[cycle %d] SPI0 access: %h(%b) < %h > <%h>",cycle,{prev_mem_addr, 2b00},prev_mem_rw,prev_wdata,memio.rdata);
                }
                if (spi1_en) {
                    __display("[cycle %d] SPI1 access: %h(%b) < %h > <%h>",cycle,{prev_mem_addr, 2b00},prev_mem_rw,prev_wdata,memio.rdata);
                }
                if (audio_streamer_mem_en) {
                    __display("[cycle %d] AUDIO STREAMER access: %h(%b) < %h > <%h>",cycle,{prev_mem_addr, 2b00},prev_mem_rw,prev_wdata,memio.rdata);
                }
                if (~gpio_en & ~dac_en /*& ~display_peripheral_en*/ & ~spi0_en & ~spi1_en & ~audio_streamer_mem_en) {
                    __display("[cycle %d] Peripheral access to unknown address: %b",cycle,prev_mem_addr);
                }
            }
        $$end

        // Update previous memory access info
        prev_mem_addr = memio.addr;
		prev_mem_rw   = memio.wenable;
        prev_wdata    = memio.wdata;
        // SIMULATION ONLY: cycle counter to help debugging
        $$if SIMULATION then
            cycle = cycle + 1;
        $$end
    }
}

