// Pre-compilation script, embeds compiled code within a string
// Code has to be compiled into firmware/code.hex before
$$dofile('pre_include_compiled.lua')

// -- Includes -- //

// Includes the processor
$include('../lib/silice/projects/ice-v/CPUs/ice-v.si')

// Includes the SPIscreen driver
$$ OLED_SLOW=1
$include('../lib/silice/projects/ice-v/SOCs/ice-v-oled.si')

// Includes the GPIO peripheral
$include('./gpio.si')
// Includes the SPI peripheral
$include('./spi.si')
// -- End of Includes -- //

// Setup memory size
// - addrW is the address bus width
// - the topmost bit is used to indicate peripheral access
// - we thus allocate 2^(addrW-1) uint32 of RAM
// - See ../svd.xml for memory map
$$addrW      = 15
$$periph_bit = addrW-1
// Configure BRAM (needed for write mask)
$$config['bram_wmask_byte_wenable_width'] = 'data'


// Memory interface between SOC and CPU
group mem_io
{
    uint4       wenable(0), // write enable mask (xxxx, 0:nop, 1:write)
    uint32      wdata(0),   // data to write
    uint32      rdata(0),   // data read from memory
    uint$addrW$ addr(0),    // address, init is boot address
}

// --------------------------------------------------
// SOC unit (main)
// --------------------------------------------------
//   some input/outputs do not exist in simulation and
//   are therefore enclosed in pre-processor conditions
unit main(
    output uint8 leds,
$$if BUTTONS then
    input  uint7 btns,
$$end
$$if AUDIO then
    output uint4 audio_l,
    output uint4 audio_r,
$$end
    output uint1 oled_clk,
    output uint1 oled_mosi,
    output uint1 oled_dc,
    output uint1 oled_resn,
    output! uint1 oled_csn(0),
$$if VERILATOR then
    // configuration for SPIscreen simulation
    output uint2  spiscreen_driver(1/*SSD1351*/),
    output uint10 spiscreen_width(128),
    output uint10 spiscreen_height(128),
$$end
$$if SDCARD then
    output!  uint1  sd_clk,
    output!  uint1  sd_csn(1),
    output!  uint1  sd_mosi,
    input   uint1  sd_miso,
$$end
) {

// -- Fallbacks for simulation -- //
$$if SIMULATION then
    // count cycles in simulation for debugging purposes
    uint32 cycle(0);
$$end

$$if not SDCARD then
    // for simulation ('fake' inputs/outputs)
    uint1  sd_clk(0);
    uint1  sd_csn(0);
    uint1  sd_mosi(0);
    uint1  sd_miso(0);
$$end

$$if not BUTTONS then
    // for simulation ('fake' inputs/outputs)
    uint7 btns(4);
$$end

$$if not AUDIO then
    // for simulation ('fake' inputs/outputs)
    uint4 audio_l(0);
    uint4 audio_r(0);
$$end
// -- End of fallbacks -- //
    // Instantiate the Memory Interface
    mem_io memio;

    // Instantiate our CPU
    rv32i_cpu cpu( mem <:> memio );

    // Instantiate the memory (BRAM)
    bram uint32 ram<"bram_wmask_byte">[$1<<(addrW-1)$] = $meminit$;

    // -- Peripherals -- //
    // GPIO Peripheral
    uint1 gpio_en(0);
    uint1 gpio_rst(0);
    uint1 gpio_oled_csn(0);     // GPIO - OLED (only connected when Hardware Framebuffer is Disabled)
    uint1 gpio_oled_mosi(0);    // GPIO - OLED (only connected when Hardware Framebuffer is Disabled)
    uint1 gpio_oled_clk(0);     // GPIO - OLED (only connected when Hardware Framebuffer is Disabled)
    uint1 gpio_oled_dc(0);      // GPIO - OLED (only connected when Hardware Framebuffer is Disabled)
    uint1 gpio_oled_resn(0);    // GPIO - OLED (only connected when Hardware Framebuffer is Disabled)
    gpio_peripheral gpio(
        rst <: gpio_rst, // no reset for now
        // Memory-mapped I/O interface
        mem_en      <: gpio_en,
        // mem_addr    <: prev_mem_addr[0,8],
        // mem_wr_data <: prev_wdata,
        // mem_wr_en   <: prev_mem_rw,
        // mem_rd_data :> memio.rdata,
        // GPIO signals
        leds        :> leds,
        btns        <: btns,
        // SPI - SD Card
        sd_cs       :> sd_csn,
        sd_mosi     :> sd_mosi,
        sd_clk      :> sd_clk,
        sd_miso     <: sd_miso,
        // SPI - OLED Display
        oled_cs     :> gpio_oled_csn,
        oled_mosi   :> gpio_oled_mosi,
        oled_clk    :> gpio_oled_clk,
        oled_dc     :> gpio_oled_dc,
        oled_res    :> gpio_oled_resn,
    );

    // SPI Peripherals
    /* TODO
    uint1 spi0_en(0);
    uint1 spi0_rst(0);
    uint1 spi0_rclk(0);
    uint8 spi0_clk_cntr(0);
    $$if SIMULATION then
    uint1 spi0_busy(0);
    uint1 spi0_ready(0);
    $$end
    spi_peripheral spi0(
        rclk       <: spi0_rclk,
        rst        <: spi0_rst,
        //mem_addr   (prev_mem_addr[0,8]),
        //mem_wr_data(prev_wdata),
        //mem_wr_en  (prev_mem_rw),
        //mem_rd_data(spi0.mem_rd_data),
        spi_clk    :> sd_clk,
        spi_mosi   :> sd_mosi,
        spi_miso   <: sd_miso,
        $$if SIMULATION then
            debug_busy :> spi0_busy,
            debug_ready :> spi0_ready,
        $$end
    );
    */

    // -- End of Peripherals -- //

    // -- Internal SoC states -- //
    // Variables to record previous cycle CPU access (peripherals memory mapping)
    // The CPU issues a memory request a cycle i and expects the result at i+1
    uint$addrW$ prev_mem_addr(0);
    uint4       prev_mem_rw(0);
    uint32      prev_wdata(0);
    // -- End of Internal SoC states -- //


    always { 
        // SPI rclk generation (for SPI0 peripheral)
        // Generate a clock at ~400kHz from the main clock (assumed 25MHz)
        /*
        spi0_clk_cntr = spi0_clk_cntr + 1;
        if (spi0_clk_cntr == 63) { // 25MHz / 64 = 390.625kHz
            spi0_clk_cntr = 0;
            spi0_rclk     = ~spi0_rclk;
            $$if SIMULATION then
                //if (spi0_busy) {
                //    __display("[cycle %d] SPI0 RCLK=%b BUSY=%b READY=%b, SPI_CLK=%b, MOSI=%b, MISO=%b", cycle, spi0_rclk, spi0_busy, spi0_ready, sd_clk, sd_mosi, sd_miso);
                //}
            $$end
        }
        */

        // Peripheral enable signals
        uint1 peripheral_en = prev_mem_addr[$periph_bit$,1];
        gpio_en = peripheral_en & (prev_mem_addr[8, 6] == 6b000001); // GPIO at 0x10400 = 0b100000100000000
        //spi0_en = peripheral_en & (prev_mem_addr[8, 6] == 6b000011); // SPI0 at 0x10C00 = 0b100001100000000

        // GPIO Peripheral memory-mapped I/O access
        gpio.mem_addr    = prev_mem_addr[0,8];
        gpio.mem_wr_data = prev_wdata;
        gpio.mem_wr_en   = prev_mem_rw;

        // SPI0 Peripheral memory-mapped I/O access
        /* TODO
        spi0.mem_addr    = prev_mem_addr[0,8];
        spi0.mem_wr_data = prev_wdata;
        spi0.mem_wr_en   = prev_mem_rw;
        */

        // Display signals for OLED when Hardware Framebuffer is disabled
        oled_csn  = gpio_oled_csn;
        oled_mosi = gpio_oled_mosi;
        oled_clk  = gpio_oled_clk;
        oled_dc   = gpio_oled_dc;
        oled_resn = gpio_oled_resn;

        // Memory Interface
        memio.rdata =   (~peripheral_en ? ram.rdata : 32b0)
                        | (peripheral_en & gpio_en ? gpio.mem_rd_data : 32b0);
                        // TODO : | (peripheral_en & spi0_en ? spi0.mem_rd_data : 32b0);
        ram.wenable = memio.wenable & {4{~memio.addr[$periph_bit$,1]}};
        //                               ^^^^^^^ no write if on peripheral addresses
        ram.wdata        = memio.wdata;
        ram.addr         = memio.addr;

        // SIMULATION ONLY: debug output for LEDs
        $$if SIMULATION then
            if (peripheral_en) {
                if (gpio_en) {
                    __display("[cycle %d] GPIO access: %h(%b) < %h > <%h>",cycle,{prev_mem_addr, 2b00},prev_mem_rw,prev_wdata,memio.rdata);
                }
                // if (spi0_en) {
                //     __display("[cycle %d] SPI0 access: %h(%b) < %h > <%h>",cycle,{prev_mem_addr, 2b00},prev_mem_rw,prev_wdata,memio.rdata);
                // }
                if (~gpio_en /*& ~spi0_en*/) {
                    __display("[cycle %d] Peripheral access to unknown address: %b",cycle,prev_mem_addr);
                }
            }
        $$end

        // Update previous memory access info
        prev_mem_addr = memio.addr;
		prev_mem_rw   = memio.wenable;
        prev_wdata    = memio.wdata;
        // SIMULATION ONLY: cycle counter to help debugging
        $$if SIMULATION then
            cycle = cycle + 1;
        $$end
    }
}

