// Import DAC module
$include('./dac.si')

/// Audio Streamer Peripheral
unit audio_streamer_peripheral(
    // Memory-mapped I/O interface
    input  uint8        mem_addr,
    input  uint32       mem_wr_data,
    input  uint4        mem_wr_en,
    output! uint32      mem_rd_data(32h00000000),
    // Audio Output signals
    output uint4        audio_left_out(4b0000),
    output uint4        audio_right_out(4b0000),
    // Peripheral enabled signal - indicates if audio streaming is active
    output uint1        enabled(0)
) {
    // Register addresses (word-aligned)
    uint10 REG_CONTROL_RW(10h00); // Control Read/Write
    uint10 REG_DATA_W(10h04);     // Data Write

    // Control register bits
    uint1 control_enable(0);       // Bit 0: Enable audio streaming
    uint1 control_stereo(0);       // Bit 1: Stereo (1) / Mono (0) mode
    // Internal data register sync
    uint8 ctrl_data_wid(8h00); // On write on register DATA, a Write-ID must be provided (only when this ID changes, the data will accounted in the buffer)

    // Audio buffer (1024 samples - 512 left, 512 right or 1024 mono)
    simple_dualport_bram uint8 audio_buffer[1024] = {pad(0)};
    uint10 buffer_read_cursor(0); // read cursor (start of the ring buffer)
    uint10 buffer_write_cursor(0); // write cursor (end of the ring buffer)
    // length is write - read (modulo buffer size)

    // DAC output samples
    uint8 audio_left_sample(8b00000000);
    uint8 audio_right_sample(8b00000000);

    // 8kHz sampling rate "reference" clock
    uint16 dac_counter(0);

    // Instantiate DAC units for left and right audio channels
    dac dac_left(
        in <: audio_left_sample,
        out :> audio_left_out
    );

    dac dac_right(
        in <: audio_right_sample,
        out :> audio_right_out
    );

    always {
        // Handle memory-mapped I/O
        uint10 mem_addr_ext = {mem_addr, 2b00}; // Extend to word-aligned address
        uint1 access_reg_ctrl        = (mem_addr_ext == REG_CONTROL_RW);
        uint1 access_reg_data        = (mem_addr_ext == REG_DATA_W);

        // Handle read from control register
        uint10 buffer_length = buffer_write_cursor - buffer_read_cursor; // current buffer length (note: wraps around automatically but might overflow)
        uint1 q_empty = (buffer_length == 0) ? 1 : 0;
        uint1 q_full  = (buffer_length == 1023) ? 1 : 0;
        uint1 q_almost_full = (buffer_length >= (1024-1-32)) ? 1 : 0;
        uint1 q_almost_empty = (buffer_length <= 32) ? 1 : 0;
        mem_rd_data = (access_reg_ctrl ? {26b0, q_empty, q_almost_empty, q_almost_full, q_full, control_stereo, control_enable} : 32h00000000);

        // Prepare audio_buffer for this cycle
        audio_buffer.wenable1 = 0; // default no write
        audio_buffer.addr1 = buffer_write_cursor; // if a write occurs, it will happens there
        // read address advances only when enabled, dac_counter hits 0 (so at 8kHz) and buffer not empty
        buffer_read_cursor = (control_enable && dac_counter == 0 && buffer_length != 0) ? (buffer_read_cursor + 1) : buffer_read_cursor;
        audio_buffer.addr0 = buffer_read_cursor; // read from current read cursor

        // Update dac at the sampling rate (8kHz)
        audio_left_sample = control_enable ? audio_buffer.rdata0 : 8b00000000;
        audio_right_sample = control_enable ? audio_buffer.rdata0 : 8b00000000;

        // Handle write to registers
        if (mem_wr_en != 4b0000) {
            // Handle write to control register
            control_enable = (access_reg_ctrl & mem_wr_en[0,1]) ? mem_wr_data[0,1] : control_enable;
            control_stereo = (access_reg_ctrl & mem_wr_en[0,1]) ? mem_wr_data[1,1] : control_stereo;

            // Handle write to data register
            audio_buffer.wdata1 = (access_reg_data & mem_wr_en[0,1]) ? mem_wr_data[0,8] : 8b00000000;
            audio_buffer.wenable1 = (access_reg_data & mem_wr_en[0,1]) ? 1 : 0;

            // Check if the write ID has changed
            // If so, advance the write cursor
            uint8 new_wid = (access_reg_data & mem_wr_en[1,1]) ? mem_wr_data[8,8] : ctrl_data_wid;
            buffer_write_cursor = (new_wid != ctrl_data_wid) ? (buffer_write_cursor + 1) : buffer_write_cursor;
            ctrl_data_wid = new_wid;
        }

        // DAC clock divider 3125 for 8kHz sampling rate (assuming system clock is 25MHz)
        // 25,000,000 / 8,000 = 3125
        // 25,000,000 / 48,000 = 520.8 (~521 meaning it will be slightly late)
        dac_counter = (dac_counter == 520) ? 0 : (dac_counter + 1);

        // SIMULATION ONLY: debug
        $$if SIMULATION then
            if (control_enable && dac_counter == 0) {
                __display("audio streamer> enable: %b, new sample: %h, buflen: %d, bufread: %h, bufwrite: %h", control_enable, audio_left_sample, buffer_length, buffer_read_cursor, buffer_write_cursor);
            }
        $$end
    }
}
