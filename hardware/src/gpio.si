/// GPIO (General Purpose Input/Output) Peripheral
unit gpio_peripheral(
    input  uint1        rst,
    // Memory-mapped I/O interface
    input  uint1        mem_en,      // enable signal
    input  uint8        mem_addr,
    input  uint32       mem_wr_data,
    input  uint4        mem_wr_en,
    output! uint32       mem_rd_data(32b0),
    // GPIO signals
    output uint8        leds(8h00),
    input  uint7        btns
) {
    // Register addresses (word-aligned)
    uint10 REG_LED_RW(10h00); // LED Read/Write
    uint10 REG_BTN_R(10h04); // Button Read-only

    always {
        uint10 mem_addr_ext = {mem_addr, 2b00}; // Extend to word-aligned address
        uint1 leds_access            = (mem_addr_ext == REG_LED_RW); 
        uint1 button_access          = (mem_addr_ext == REG_BTN_R);

        // Handle read from GPIO peripheral
        mem_rd_data = (mem_en & leds_access) ? {24b0, leds} :
                      (mem_en & button_access) ? {25b0, btns} :
                      32b0;

        // Handle write to GPIO peripheral
        if (~rst & mem_en & (mem_wr_en != 4b0000)) {
            // Update LEDs
            uint8 led_mask = leds_access ? mem_wr_data[8,8] : 8h00;
            leds           = (leds & ~led_mask) | (mem_wr_data[0,8] & led_mask);
            
            // BTN - read-only, no write operation
        }
        if (rst) {
            leds = 8h00; // Reset LEDs to 0 on reset
        }

        // SIMULATION ONLY: debug output for LEDs
        $$if SIMULATION then
            if (mem_en & leds_access) {
                __display("LEDs: %b (%b(%b) > %h)",leds,mem_addr,mem_wr_en,mem_wr_data);
            }
            if (mem_en & button_access) {
                __display("Buttons read: %b",btns);
            }
        $$end
    }
}
