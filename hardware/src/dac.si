/// Simple 8-bit to 4-bit DAC using PWM
/// Input: 8-bit audio sample (0-255)
/// Output: 4-bit PWM value (0-15)
///
/// The PWM frequency is set to 100 kHz, which should be sufficient for audio output
unit dac(
    input uint8 in,
    output uint4 out,
    output uint1 next,
){
    // 100 kHz PWM counter = 250 cycles at 25 MHz clock
    // next signal indicates when to load the next sample - when counter is in range 240-249
    uint8 cycle(0);

    always {
        
        // cycle counter for PWM
        cycle = (cycle == 249) ? 0 : cycle + 1;

        // Interpolate the high-bits between the 4-bit DAC levels.
        uint4 dac_low = in[4,4]; // Top 4 bits of input - also the DAC low level for this sample
        uint4 dac_high = (dac_low == 15) ? dac_low : (dac_low + 1); // DAC high level for this sample (saturate at max)
        uint8 pwm_duty = {in[0,4],4b0000}; // PWM duty cycle (0-240)

        // Determine output level based on PWM duty cycle
        if (cycle < pwm_duty) {
            out = dac_high;
        } else {
            out = dac_low;
        }

        // next signal when cycle is in range 240-249
        next = (cycle == 240) ? 1 : (cycle == 249) ? 0 : next;
        
        //out = in[4,4]; // Directly map top 4 bits to output
    }
}

/// Audio DAC Peripheral
unit dac_peripheral(
    // Memory-mapped I/O interface
    input  uint8        mem_addr,
    input  uint32       mem_wr_data,
    input  uint4        mem_wr_en,
    // output! uint32   mem_rd_data(32b0), - No reads for this peripheral
    // Audio Output signals
    output uint4        audio_left_out(4b0000),
    output uint4        audio_right_out(4b0000)
) {
    // Register addresses (word-aligned)
    uint10 REG_OUTPUT_W(10h00); // Output Write

    uint8 audio_left_sample(8b00000000);
    uint8 audio_right_sample(8b00000000);

    // Instantiate DAC units for left and right audio channels
    dac dac_left(
        in <: audio_left_sample,
        out :> audio_left_out
    );

    dac dac_right(
        in <: audio_right_sample,
        out :> audio_right_out
    );

    always {
        uint10 mem_addr_ext = {mem_addr, 2b00}; // Extend to word-aligned address
        uint1 access        = (mem_addr_ext == REG_OUTPUT_W);

        // Handle read from GPIO peripheral
        // mem_rd_data = 32b0;

        // Handle write to GPIO peripheral
        if ((mem_wr_en != 4b0000)) {
            // Update audio output if writing to output register
            audio_left_sample  = access & mem_wr_en[0,1] ? mem_wr_data[0,8]   : audio_left_sample;
            audio_right_sample = access & mem_wr_en[1,1] ? mem_wr_data[8,8] : audio_right_sample;
        }
    }
}
